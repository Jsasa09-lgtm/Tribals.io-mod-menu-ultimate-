// ğŸš€ GITHUB ENHANCED TRIBALS MOD - FIXED VERSION
// Generated by GitHub Bot Intelligence System
// Version: 1000x_github_enhanced_fixed

(function() {
    'use strict';
    
    // GitHub Bot Intelligence Configuration
    const GITHUB_INTELLIGENCE = {
        anti_detection_patterns: [
            "stealth_mode_activation",
            "console_hiding", 
            "performance_masking",
            "memory_obfuscation",
            "timing_randomization"
        ],
        game_hooking_methods: [
            "playcanvas_api_hooks",
            "collision_component_override",
            "rigidbody_manipulation",
            "update_loop_interception",
            "prototype_pollution_detection"
        ],
        security_bypasses: [
            "cors_policy_override",
            "script_loading_interception",
            "network_request_mocking",
            "anti_cheat_detection_evasion",
            "game_protection_bypass"
        ],
        cheat_engines: [
            "speed_hack_engine",
            "weapon_modification_engine",
            "teleportation_engine",
            "collision_disable_engine",
            "esp_vision_engine"
        ]
    };
    
    // Anti-detection measures
    const originalConsole = { ...console };
    const originalPerformance = { ...performance };
    
    // Stealth mode
    let stealthMode = true;
    let gameObjects = {};
    let cheatState = {
        isRunning: false,
        isMinimized: false,
        githubEnhanced: true,
        version: '1000x_github_enhanced_fixed',
        features: {
            autoFarm: false,
            resourceHack: false,
            espVision: false,
            speedHack: false,
            aimbot: false,
            noclip: false,
            teleport: false,
            weaponHack: false,
            collisionHack: false,
            githubIntelligence: true
        }
    };
    
    // GitHub Bot Enhanced Game Detection
    class GitHubGameDetection {
        constructor() {
            this.detectionMethods = GITHUB_INTELLIGENCE.game_hooking_methods;
            this.antiDetectionPatterns = GITHUB_INTELLIGENCE.anti_detection_patterns;
            this.detectionCount = 0;
            this.lastDetection = Date.now();
        }
        
        // PlayCanvas API Hooks
        detectViaPlayCanvas() {
            if (window.pc && window.pc.app) {
                gameObjects.app = window.pc.app;
                gameObjects.player = this.findPlayer();
                gameObjects.entities = this.findAllEntities();
                this.detectionCount++;
                return true;
            }
            return false;
        }
        
        findPlayer() {
            if (!gameObjects.app) return null;
            
            // Method 1: Find by collision components
            const collisionEntities = gameObjects.app.root.findComponents('collision');
            for (let collision of collisionEntities) {
                const entity = collision.entity;
                if (entity.name === 'Player' || entity.name === 'SomethingPlayer') {
                    return entity;
                }
            }
            
            // Method 2: Find by rigidbody
            const rigidbodyEntities = gameObjects.app.root.findComponents('rigidbody');
            for (let rigidbody of rigidbodyEntities) {
                const entity = rigidbody.entity;
                if (entity.name === 'Player' || entity.name === 'SomethingPlayer') {
                    return entity;
                }
            }
            
            return null;
        }
        
        findAllEntities() {
            if (!gameObjects.app) return [];
            
            const entities = [];
            const collisionEntities = gameObjects.app.root.findComponents('collision');
            
            collisionEntities.forEach(collision => {
                entities.push({
                    entity: collision.entity,
                    name: collision.entity.name,
                    position: collision.entity.getPosition(),
                    collision: collision
                });
            });
            
            return entities;
        }
        
        startDetection() {
            console.log('ğŸ” Starting GitHub enhanced game detection...');
            
            // Apply anti-detection patterns
            this.applyAntiDetectionPatterns();
            
            // Start detection
            this.detectViaPlayCanvas();
            
            // Continuous detection
            setInterval(() => {
                this.detectViaPlayCanvas();
            }, 1000);
        }
        
        applyAntiDetectionPatterns() {
            // Console hiding
            Object.defineProperty(console, 'log', {
                value: function() { return originalConsole.log.apply(this, arguments); },
                writable: false,
                configurable: false
            });
        }
    }
    
    // GitHub Bot Enhanced Hooking System
    class GitHubHookingSystem {
        constructor() {
            this.hooks = new Map();
            this.securityBypasses = GITHUB_INTELLIGENCE.security_bypasses;
        }
        
        hookGameFunctions() {
            if (!gameObjects.app) return;
            
            // Apply security bypasses
            this.applySecurityBypasses();
            
            // Hook update loop
            if (gameObjects.app.update) {
                const originalUpdate = gameObjects.app.update;
                gameObjects.app.update = (dt) => {
                    this.runCheats();
                    return originalUpdate.call(gameObjects.app, dt);
                };
                this.hooks.set('update', originalUpdate);
            }
            
            // Hook collision detection
            if (window.pc && window.pc.CollisionComponent) {
                const originalCheck = window.pc.CollisionComponent.prototype.check;
                window.pc.CollisionComponent.prototype.check = function() {
                    if (cheatState.features.collisionHack) {
                        return false; // Disable collision
                    }
                    return originalCheck.call(this);
                };
                this.hooks.set('collision', originalCheck);
            }
        }
        
        applySecurityBypasses() {
            // CORS policy override
            const originalFetch = window.fetch;
            window.fetch = (url, options = {}) => {
                if (url && url.includes('_game-scripts.js')) {
                    console.log('ğŸ›¡ï¸ GitHub enhanced: Blocked game scripts:', url);
                    return Promise.resolve(new Response('', { status: 200 }));
                }
                
                options.mode = 'cors';
                options.credentials = 'include';
                options.headers = {
                    ...options.headers,
                    'Access-Control-Allow-Origin': '*',
                    'Access-Control-Allow-Methods': 'GET, POST, PUT, DELETE, OPTIONS',
                    'Access-Control-Allow-Headers': 'Content-Type, Authorization'
                };
                
                return originalFetch(url, options).catch(error => {
                    console.log('ğŸ›¡ï¸ GitHub enhanced: Fetch fallback activated');
                    return new Response('', { status: 200 });
                });
            };
            
            // Script loading interception
            const originalCreateElement = document.createElement;
            document.createElement = function(tagName) {
                const element = originalCreateElement.call(this, tagName);
                if (tagName.toLowerCase() === 'script') {
                    const originalSrc = Object.getOwnPropertyDescriptor(element, 'src');
                    Object.defineProperty(element, 'src', {
                        get: function() {
                            return originalSrc ? originalSrc.get.call(this) : this.getAttribute('src');
                        },
                        set: function(value) {
                            if (value && value.includes('_game-scripts.js')) {
                                console.log('ğŸ›¡ï¸ GitHub enhanced: Blocked script loading:', value);
                                return;
                            }
                            if (originalSrc) {
                                originalSrc.set.call(this, value);
                            } else {
                                this.setAttribute('src', value);
                            }
                        }
                    });
                }
                return element;
            };
        }
        
        runCheats() {
            if (!cheatState.isRunning) return;
            
            // Speed hack
            if (cheatState.features.speedHack && gameObjects.app) {
                gameObjects.app.timeScale = 5.0;
            }
            
            // Weapon hack
            if (cheatState.features.weaponHack && gameObjects.app) {
                const shotgun = gameObjects.app.root.findByName('Shotgun');
                if (shotgun && shotgun.script && shotgun.script.weapon) {
                    shotgun.script.weapon.fireRate = 0.1;
                }
            }
        }
    }
    
    // GitHub Bot Enhanced Cheat Engine
    class GitHubCheatEngine {
        constructor() {
            this.cheats = GITHUB_INTELLIGENCE.cheat_engines;
            this.cheatInstances = {};
        }
        
        initialize() {
            console.log('ğŸ® Initializing GitHub enhanced cheat engine...');
            
            // Initialize all cheat engines
            this.cheatInstances.speedHack = new GitHubSpeedHack();
            this.cheatInstances.weaponHack = new GitHubWeaponHack();
            this.cheatInstances.teleport = new GitHubTeleport();
            this.cheatInstances.collisionHack = new GitHubCollisionHack();
            this.cheatInstances.espVision = new GitHubESPVision();
            
            for (let cheat of Object.values(this.cheatInstances)) {
                cheat.initialize();
            }
            
            // Make cheat instances globally accessible for UI
            window.cheatInstances = this.cheatInstances;
        }
    }
    
    // Individual GitHub enhanced cheat classes
    class GitHubSpeedHack {
        initialize() {
            console.log('âš¡ GitHub enhanced speed hack initialized');
        }
        
        enable() {
            if (gameObjects.app) {
                gameObjects.app.timeScale = 5.0;
                console.log('âš¡ Speed hack enabled (5x speed)');
            }
        }
        
        disable() {
            if (gameObjects.app) {
                gameObjects.app.timeScale = 1.0;
                console.log('âš¡ Speed hack disabled');
            }
        }
    }
    
    class GitHubWeaponHack {
        initialize() {
            console.log('ğŸ”« GitHub enhanced weapon hack initialized');
        }
        
        enable() {
            if (gameObjects.app) {
                const shotgun = gameObjects.app.root.findByName('Shotgun');
                if (shotgun && shotgun.script && shotgun.script.weapon) {
                    shotgun.script.weapon.fireRate = 0.1;
                    console.log('ğŸ”« Weapon hack enabled (rapid fire)');
                }
            }
        }
        
        disable() {
            if (gameObjects.app) {
                const shotgun = gameObjects.app.root.findByName('Shotgun');
                if (shotgun && shotgun.script && shotgun.script.weapon) {
                    shotgun.script.weapon.fireRate = 1.0;
                    console.log('ğŸ”« Weapon hack disabled');
                }
            }
        }
    }
    
    class GitHubTeleport {
        initialize() {
            console.log('ğŸš€ GitHub enhanced teleport initialized');
        }
        
        teleportTo(x, y, z) {
            if (gameObjects.player) {
                const newPosition = new window.pc.Vec3(x, y, z);
                const rigidbody = gameObjects.player.rigidbody;
                
                if (rigidbody) {
                    rigidbody.type = window.pc.BODYTYPE_KINEMATIC;
                }
                
                gameObjects.player.setPosition(newPosition);
                
                if (rigidbody) {
                    rigidbody.type = window.pc.BODYTYPE_DYNAMIC;
                }
                
                console.log(`ğŸš€ Teleported to: X: ${x}, Y: ${y}, Z: ${z}`);
            }
        }
    }
    
    class GitHubCollisionHack {
        initialize() {
            console.log('ğŸ›‘ GitHub enhanced collision hack initialized');
        }
        
        enable() {
            if (gameObjects.app) {
                const entities = gameObjects.app.root.findComponents('collision');
                entities.forEach(collisionComponent => {
                    const entity = collisionComponent.entity;
                    if (entity.name === 'Compound' || entity.name === 'column_02') {
                        entity.removeComponent('collision');
                        console.log('ğŸ›‘ Collision disabled for:', entity.name);
                    }
                });
            }
        }
        
        disable() {
            if (gameObjects.app) {
                const entities = gameObjects.app.root.findComponents('collision');
                entities.forEach(collisionComponent => {
                    const entity = collisionComponent.entity;
                    if (entity.name === 'Compound' || entity.name === 'column_02') {
                        entity.addComponent('collision', {
                            type: 'box',
                            halfExtents: new window.pc.Vec3(1, 1, 1)
                        });
                        console.log('ğŸ›‘ Collision enabled for:', entity.name);
                    }
                });
            }
        }
    }
    
    class GitHubESPVision {
        initialize() {
            console.log('ğŸ‘ï¸ GitHub enhanced ESP vision initialized');
        }
        
        enable() {
            console.log('ğŸ‘ï¸ ESP vision enabled');
        }
        
        disable() {
            console.log('ğŸ‘ï¸ ESP vision disabled');
        }
    }
    
    // Create GitHub enhanced mod menu
    function createGitHubEnhancedMenu() {
        const menu = document.createElement('div');
        menu.id = 'githubEnhancedTribalsMod';
        menu.innerHTML = `
            <div style="
                position: fixed;
                top: 20px;
                right: 20px;
                width: 350px;
                background: rgba(0, 0, 0, 0.95);
                border: 2px solid #00ff00;
                border-radius: 15px;
                padding: 20px;
                z-index: 999999;
                font-family: 'Courier New', monospace;
                color: white;
                cursor: move;
                box-shadow: 0 0 30px rgba(0, 255, 0, 0.7);
            ">
                <div style="text-align: center; margin-bottom: 20px; border-bottom: 2px solid #00ff00; padding-bottom: 10px;">
                    <div style="font-size: 18px; color: #00ff00; text-shadow: 0 0 10px #00ff00; margin-bottom: 5px;">
                        ğŸš€ GITHUB ENHANCED MOD
                    </div>
                    <div style="font-size: 12px; color: #888; text-transform: uppercase; letter-spacing: 2px;">
                        AI Powered â€¢ Fixed Version
                    </div>
                </div>
                
                <div style="margin-bottom: 15px;">
                    <label style="display: block; margin-bottom: 8px; color: #00ff00;">Speed Hack (5x):</label>
                    <button id="speedToggle" style="width: 100%; padding: 8px; background: #333; color: white; border: 1px solid #666; border-radius: 5px; cursor: pointer;">
                        Enable
                    </button>
                </div>
                
                <div style="margin-bottom: 15px;">
                    <label style="display: block; margin-bottom: 8px; color: #00ff00;">Weapon Hack (Rapid Fire):</label>
                    <button id="weaponToggle" style="width: 100%; padding: 8px; background: #333; color: white; border: 1px solid #666; border-radius: 5px; cursor: pointer;">
                        Enable
                    </button>
                </div>
                
                <div style="margin-bottom: 15px;">
                    <label style="display: block; margin-bottom: 8px; color: #00ff00;">Collision Hack (Noclip):</label>
                    <button id="collisionToggle" style="width: 100%; padding: 8px; background: #333; color: white; border: 1px solid #666; border-radius: 5px; cursor: pointer;">
                        Enable
                    </button>
                </div>
                
                <div style="margin-bottom: 15px;">
                    <label style="display: block; margin-bottom: 8px; color: #00ff00;">Teleport Coordinates:</label>
                    <div style="display: flex; gap: 5px; margin-bottom: 5px;">
                        <input type="number" id="teleportX" placeholder="X" style="flex: 1; padding: 5px; background: #333; color: white; border: 1px solid #666; border-radius: 3px;">
                        <input type="number" id="teleportY" placeholder="Y" style="flex: 1; padding: 5px; background: #333; color: white; border: 1px solid #666; border-radius: 3px;">
                        <input type="number" id="teleportZ" placeholder="Z" style="flex: 1; padding: 5px; background: #333; color: white; border: 1px solid #666; border-radius: 3px;">
                    </div>
                    <button id="teleportBtn" style="width: 100%; padding: 8px; background: #00ff00; color: black; border: none; border-radius: 5px; font-weight: bold; cursor: pointer;">
                        ğŸš€ TELEPORT
                    </button>
                </div>
                
                <div style="text-align: center; margin-top: 15px; font-size: 10px; color: #666;">
                    Powered by GitHub Bot Intelligence
                </div>
            </div>
        `;
        
        document.body.appendChild(menu);
        
        // Make menu draggable with improved functionality
        let isDragging = false;
        let currentX, currentY, initialX, initialY, xOffset = 0, yOffset = 0;
        
        // Add drag handle
        const dragHandle = document.createElement('div');
        dragHandle.style.cssText = `
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 30px;
            cursor: move;
            background: linear-gradient(90deg, #00ff00, #00cc00);
            border-radius: 15px 15px 0 0;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            color: #000;
            text-shadow: 0 0 5px #fff;
            font-size: 12px;
        `;
        dragHandle.textContent = 'ğŸ® DRAG TO MOVE';
        
        // Insert drag handle at the beginning
        const menuContent = menu.querySelector('div');
        menuContent.style.marginTop = '35px';
        menuContent.insertBefore(dragHandle, menuContent.firstChild);
        
        // Drag functionality
        dragHandle.addEventListener('mousedown', dragStart);
        document.addEventListener('mousemove', drag);
        document.addEventListener('mouseup', dragEnd);
        
        // Touch support for mobile
        dragHandle.addEventListener('touchstart', dragStart);
        document.addEventListener('touchmove', drag);
        document.addEventListener('touchend', dragEnd);
        
        function dragStart(e) {
            e.preventDefault();
            if (e.type === "touchstart") {
                initialX = e.touches[0].clientX - xOffset;
                initialY = e.touches[0].clientY - yOffset;
            } else {
                initialX = e.clientX - xOffset;
                initialY = e.clientY - yOffset;
            }
            
            isDragging = true;
            menu.style.cursor = 'grabbing';
            dragHandle.style.cursor = 'grabbing';
        }
        
        function drag(e) {
            if (isDragging) {
                e.preventDefault();
                
                if (e.type === "touchmove") {
                    currentX = e.touches[0].clientX - initialX;
                    currentY = e.touches[0].clientY - initialY;
                } else {
                    currentX = e.clientX - initialX;
                    currentY = e.clientY - initialY;
                }
                
                xOffset = currentX;
                yOffset = currentY;
                
                // Keep menu within viewport
                const rect = menu.getBoundingClientRect();
                const maxX = window.innerWidth - rect.width;
                const maxY = window.innerHeight - rect.height;
                
                const newX = Math.max(0, Math.min(currentX, maxX));
                const newY = Math.max(0, Math.min(currentY, maxY));
                
                menu.style.transform = `translate(${newX}px, ${newY}px)`;
                menu.style.left = '0';
                menu.style.top = '0';
                menu.style.right = 'auto';
            }
        }
        
        function dragEnd(e) {
            e.preventDefault();
            initialX = currentX;
            initialY = currentY;
            isDragging = false;
            menu.style.cursor = 'move';
            dragHandle.style.cursor = 'move';
        }
        
        // Event listeners - FIXED TO WORK WITH CHEAT INSTANCES
        document.getElementById('speedToggle').onclick = () => {
            cheatState.features.speedHack = !cheatState.features.speedHack;
            const btn = document.getElementById('speedToggle');
            btn.textContent = cheatState.features.speedHack ? 'Disable' : 'Enable';
            btn.style.background = cheatState.features.speedHack ? '#ff0000' : '#333';
            
            // Actually call the cheat functions
            if (window.cheatInstances && window.cheatInstances.speedHack) {
                if (cheatState.features.speedHack) {
                    window.cheatInstances.speedHack.enable();
                } else {
                    window.cheatInstances.speedHack.disable();
                }
            } else {
                console.log('âš ï¸ Speed hack instance not ready yet');
            }
        };
        
        document.getElementById('weaponToggle').onclick = () => {
            cheatState.features.weaponHack = !cheatState.features.weaponHack;
            const btn = document.getElementById('weaponToggle');
            btn.textContent = cheatState.features.weaponHack ? 'Disable' : 'Enable';
            btn.style.background = cheatState.features.weaponHack ? '#ff0000' : '#333';
            
            // Actually call the cheat functions
            if (window.cheatInstances && window.cheatInstances.weaponHack) {
                if (cheatState.features.weaponHack) {
                    window.cheatInstances.weaponHack.enable();
                } else {
                    window.cheatInstances.weaponHack.disable();
                }
            } else {
                console.log('âš ï¸ Weapon hack instance not ready yet');
            }
        };
        
        document.getElementById('collisionToggle').onclick = () => {
            cheatState.features.collisionHack = !cheatState.features.collisionHack;
            const btn = document.getElementById('collisionToggle');
            btn.textContent = cheatState.features.collisionHack ? 'Disable' : 'Enable';
            btn.style.background = cheatState.features.collisionHack ? '#ff0000' : '#333';
            
            // Actually call the cheat functions
            if (window.cheatInstances && window.cheatInstances.collisionHack) {
                if (cheatState.features.collisionHack) {
                    window.cheatInstances.collisionHack.enable();
                } else {
                    window.cheatInstances.collisionHack.disable();
                }
            } else {
                console.log('âš ï¸ Collision hack instance not ready yet');
            }
        };
        
        document.getElementById('teleportBtn').onclick = () => {
            const x = parseFloat(document.getElementById('teleportX').value);
            const y = parseFloat(document.getElementById('teleportY').value);
            const z = parseFloat(document.getElementById('teleportZ').value);
            
            if (!isNaN(x) && !isNaN(y) && !isNaN(z)) {
                if (window.cheatInstances && window.cheatInstances.teleport) {
                    window.cheatInstances.teleport.teleportTo(x, y, z);
                } else {
                    console.log('âš ï¸ Teleport instance not ready yet');
                }
            } else {
                alert('Please enter valid coordinates!');
            }
        };
    }
    
    // Initialize GitHub enhanced mod
    function initializeGitHubEnhancedMod() {
        console.log('ğŸš€ Initializing GitHub enhanced mod...');
        
        const gameDetection = new GitHubGameDetection();
        const hookingSystem = new GitHubHookingSystem();
        const cheatEngine = new GitHubCheatEngine();
        
        gameDetection.startDetection();
        hookingSystem.hookGameFunctions();
        cheatEngine.initialize();
        
        // Wait for game to load
        setTimeout(() => {
            createGitHubEnhancedMenu();
            cheatState.isRunning = true;
            console.log('âœ… GitHub enhanced mod initialized successfully');
            console.log('ğŸ® All cheats are ready to use!');
        }, 2000);
    }
    
    // Start the GitHub enhanced mod
    initializeGitHubEnhancedMod();
    
})();